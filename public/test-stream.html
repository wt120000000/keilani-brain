<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Keilani • Stream Test</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      :root {
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial;
      }
      body {
        margin: 24px;
      }
      label {
        font-size: 12px;
        color: #555;
        display: block;
        margin-bottom: 6px;
      }
      input,
      select,
      textarea {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 8px;
      }
      textarea {
        min-height: 90px;
        resize: vertical;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .row3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 12px;
      }
      .card {
        border: 1px solid #eee;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
      }
      .btn {
        padding: 10px 16px;
        border-radius: 10px;
        border: 0;
        background: #111;
        color: #fff;
        cursor: pointer;
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        background: #fafafa;
        padding: 12px;
        border-radius: 10px;
        min-height: 120px;
      }
      .muted {
        color: #666;
        font-size: 12px;
      }
      .inline {
        display: inline-block;
        margin-right: 8px;
      }
      .switch {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
      }
      .ok {
        color: #117a37;
      }
      .bad {
        color: #b91c1c;
      }
    </style>
  </head>
  <body>
    <h1>Stream Test</h1>

    <!-- Auth helper -->
    <div class="card">
      <div class="row">
        <div>
          <label for="clientKey">Client key (stored in localStorage)</label>
          <input id="clientKey" placeholder="super-long-random-string-123456" />
          <div class="muted" style="margin-top: 6px">
            Key is read as <code>KEILANI_PUBLIC_API_KEY</code>. The
            Edge/Function expects header <code>X-Client-Key</code>.
          </div>
        </div>
        <div>
          <label>&nbsp;</label>
          <div style="display: flex; gap: 8px">
            <button id="saveKey" class="btn">Save key</button>
            <button id="clearKey" class="btn" style="background: #444">
              Clear
            </button>
            <span id="keyState" class="muted" style="align-self: center"></span>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row3">
        <div>
          <label for="model">Model</label>
          <select id="model">
            <option value="gpt-4.1-mini" selected>gpt-4.1-mini</option>
            <option value="gpt-5-mini">gpt-5-mini</option>
            <option value="gpt-5">gpt-5</option>
            <option value="gpt-4o">gpt-4o</option>
          </select>
        </div>
        <div>
          <label for="temperature">Temperature</label>
          <input
            id="temperature"
            type="number"
            step="0.1"
            min="0"
            max="2"
            value="0.7"
          />
        </div>
        <div>
          <label for="maxTokens">Max output tokens (min 16)</label>
          <input id="maxTokens" type="number" step="1" min="16" value="256" />
        </div>
      </div>

      <div class="row" style="margin-top: 12px">
        <div>
          <label for="metaSource">Metadata: source (optional)</label>
          <input id="metaSource" placeholder="e.g. keilani-dev" />
        </div>
        <div>
          <label for="endpoint">Endpoint</label>
          <select id="endpoint">
            <option value="stream" selected>/api/chat-stream (SSE)</option>
            <option value="json">/.netlify/functions/chat (JSON)</option>
          </select>
        </div>
      </div>

      <div class="switch">
        <input id="legacy" type="checkbox" />
        <label for="legacy" style="margin: 0"
          >Use legacy messages[] payload</label
        >
      </div>

      <div class="row" id="sysRow" style="margin-top: 12px; display: none">
        <div>
          <label for="system">System prompt (optional)</label>
          <input id="system" placeholder="e.g. Be concise." />
        </div>
        <div></div>
      </div>
    </div>

    <div class="card">
      <label for="message">Prompt</label>
      <textarea id="message">Say hello in 5 words.</textarea>
      <div style="margin-top: 10px">
        <button id="go" class="btn">Stream</button>
        <button
          id="stop"
          class="btn"
          style="background: #444; margin-left: 8px"
        >
          Stop
        </button>
        <span id="status" class="muted inline"></span>
      </div>
    </div>

    <div class="card">
      <div
        style="
          display: flex;
          justify-content: space-between;
          align-items: center;
        "
      >
        <div>
          <strong>Output</strong>
          <span id="reqid" class="muted" style="margin-left: 12px"></span>
        </div>
        <span id="tok" class="muted">tokens: 0</span>
      </div>
      <pre id="out"></pre>
    </div>

    <script type="module">
      import { streamChat } from "/js/streamClient.js";

      // --- DOM helpers ---
      const el = (id) => document.getElementById(id);
      const modelEl = el("model");
      const temperatureEl = el("temperature");
      const maxTokensEl = el("maxTokens");
      const sourceEl = el("metaSource");
      const endpointEl = el("endpoint");
      const legacyEl = el("legacy");
      const sysRow = el("sysRow");
      const systemEl = el("system");
      const msgEl = el("message");
      const goBtn = el("go");
      const stopBtn = el("stop");
      const out = el("out");
      const status = el("status");
      const tok = el("tok");
      const reqid = el("reqid");
      const clientKeyInput = el("clientKey");
      const keyState = el("keyState");
      const saveKeyBtn = el("saveKey");
      const clearKeyBtn = el("clearKey");

      legacyEl.onchange = () => {
        sysRow.style.display = legacyEl.checked ? "grid" : "none";
      };

      // --- client key management ---
      function refreshKeyUI() {
        const k = localStorage.getItem("KEILANI_PUBLIC_API_KEY");
        clientKeyInput.value = k ?? "";
        if (k) {
          keyState.textContent = "key present";
          keyState.className = "muted ok";
        } else {
          keyState.textContent = "no key";
          keyState.className = "muted bad";
        }
      }
      saveKeyBtn.onclick = () => {
        localStorage.setItem(
          "KEILANI_PUBLIC_API_KEY",
          clientKeyInput.value.trim(),
        );
        refreshKeyUI();
      };
      clearKeyBtn.onclick = () => {
        localStorage.removeItem("KEILANI_PUBLIC_API_KEY");
        refreshKeyUI();
      };
      refreshKeyUI();

      // --- payload builder ---
      function buildPayload() {
        const model = modelEl.value;
        const tVal = Number(temperatureEl.value);
        const maxVal = Number(maxTokensEl.value);
        const src = sourceEl.value?.trim();
        const isLegacy = legacyEl.checked;

        const base = { model };
        if (!Number.isNaN(tVal)) base.temperature = tVal;
        if (!Number.isNaN(maxVal) && maxVal >= 1)
          base.max_output_tokens = maxVal;
        if (src) base.metadata = { source: src };

        if (isLegacy) {
          const messages = [];
          const sys = systemEl.value?.trim();
          if (sys) messages.push({ role: "system", content: sys });
          messages.push({ role: "user", content: msgEl.value });
          return { ...base, messages };
        }
        return { ...base, message: msgEl.value };
      }

      // --- UI state ---
      let controller = null;
      let tokenCount = 0;

      function reset() {
        out.textContent = "";
        status.textContent = "";
        tok.textContent = "tokens: 0";
        reqid.textContent = "";
        tokenCount = 0;
      }

      stopBtn.onclick = () => {
        controller?.abort();
        controller = null;
        status.textContent = "stopped";
        goBtn.disabled = false;
      };

      goBtn.onclick = async () => {
        reset();
        goBtn.disabled = true;

        const payload = buildPayload();
        const which = endpointEl.value;
        const clientKey = localStorage.getItem("KEILANI_PUBLIC_API_KEY") || "";

        if (!clientKey) {
          status.textContent = "missing client key";
          goBtn.disabled = false;
          return;
        }

        if (which === "json") {
          // Non-streaming JSON request
          try {
            const resp = await fetch("/api/chat", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-Client-Key": clientKey, // <-- send key
              },
              body: JSON.stringify(payload),
            });

            const requestId =
              resp.headers.get("x-openai-request-id") ||
              resp.headers.get("openai-request-id") ||
              "";
            if (requestId) reqid.textContent = `request-id: ${requestId}`;

            const data = await resp.json();

            // best-effort text extraction
            let text = "";
            try {
              const msg = data?.output?.[0];
              if (msg?.content?.length) {
                const part =
                  msg.content.find((p) => p.type === "output_text") ||
                  msg.content[0];
                text = part?.text || "";
              }
            } catch {}
            out.textContent = text || JSON.stringify(data, null, 2);
            tok.textContent = `tokens: ${data?.usage?.total_tokens ?? 0}`;
            status.textContent = resp.ok ? "completed" : "error";
          } catch (err) {
            out.textContent = String(err);
            status.textContent = "error";
          } finally {
            goBtn.disabled = false;
          }
          return;
        }

        // Streaming SSE path
        controller = new AbortController();
        status.textContent = "streaming…";

        try {
          // NOTE: streamClient.js should read KEILANI_PUBLIC_API_KEY from localStorage
          // and set the "X-Client-Key" header itself. If you're on an older file,
          // update it—or fall back to the JSON path above.
          await streamChat(payload, {
            signal: controller.signal,
            onHeaders: (rid) => {
              if (rid) reqid.textContent = `request-id: ${rid}`;
            },
            onToken: (t) => {
              out.textContent += t;
              tokenCount += 1;
              tok.textContent = `tokens: ${tokenCount}`;
            },
            onDone: () => {
              status.textContent = "done";
              goBtn.disabled = false;
            },
            onError: (e) => {
              status.textContent = "error";
              out.textContent += "\n\nERR: " + (e?.message || e);
              goBtn.disabled = false;
            },
          });
        } catch (e) {
          status.textContent = "error";
          out.textContent += "\n\nERR: " + (e?.message || e);
          goBtn.disabled = false;
        }
      };
    </script>
  </body>
</html>
