<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />
    <title>Keilani Chat • Streaming</title>
    <link rel="icon" href="/favicon.ico" />
    <!-- Fonts (system stack to keep CSP happy) -->
    <style>
      :root {
        --bg: #0c0f13;
        --panel: #0f141b;
        --muted: #7a8699;
        --text: #e6edf6;
        --bubble-user: #1d2a38;
        --bubble-ai: #121a23;
        --error: #2a0f14;
        --brand: #7c5cff;
        --brand-2: #00e1ff;
        --ok: #33d17a;
        --warn: #f5c542;
        --radius: 16px;
        --radius-lg: 22px;
        --shadow: 0 6px 22px rgba(0, 0, 0, 0.25);
      }
      [data-theme="light"] {
        --bg: #f6f7fb;
        --panel: #ffffff;
        --muted: #667085;
        --text: #101828;
        --bubble-user: #eef2f7;
        --bubble-ai: #f9fafb;
        --error: #ffe8ea;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font:
          14px/1.45 ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          Apple Color Emoji,
          Segoe UI Emoji;
      }
      .wrap {
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 10;
        backdrop-filter: saturate(120%) blur(6px);
        background:
          linear-gradient(
            90deg,
            rgba(124, 92, 255, 0.1),
            rgba(0, 225, 255, 0.1)
          ),
          var(--panel);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        padding: 10px;
      }
      header .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .title {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--ok);
        box-shadow: 0 0 0 3px rgba(51, 209, 122, 0.2);
      }
      select,
      input,
      button,
      .pill {
        background: #0a0f14;
        color: var(--text);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 8px 10px;
        border-radius: 10px;
        outline: none;
        height: 36px;
      }
      [data-theme="light"] select,
      [data-theme="light"] input,
      [data-theme="light"] button,
      [data-theme="light"] .pill {
        background: #fff;
        border-color: #e6e8ee;
      }
      .grow {
        flex: 1;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .ghost {
        background: transparent;
      }
      .iconbtn {
        width: 36px;
        display: inline-grid;
        place-items: center;
      }
      .danger {
        background: var(--error);
        border-color: transparent;
      }
      .brand {
        background: linear-gradient(90deg, var(--brand), var(--brand-2));
        border-color: transparent;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", monospace;
      }
      /* chat */
      .scroll {
        flex: 1;
        overflow: auto;
        padding: 20px 16px;
      }
      .chat {
        max-width: 980px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .msg {
        display: flex;
        gap: 10px;
      }
      .msg .bubble {
        max-width: 85%;
        padding: 12px 14px;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow);
        position: relative;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      .me .bubble {
        margin-left: auto;
        border-bottom-right-radius: 8px;
        background: var(--bubble-user);
      }
      .ai .bubble {
        margin-right: auto;
        border-bottom-left-radius: 8px;
        background: var(--bubble-ai);
      }
      .bubble pre {
        background: #0a0f14;
        padding: 12px;
        border-radius: 12px;
        overflow: auto;
      }
      [data-theme="light"] .bubble pre {
        background: #eef2f7;
      }
      .meta {
        font-size: 12px;
        color: var(--muted);
        margin-top: 6px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .toolbar {
        position: absolute;
        top: 6px;
        right: 6px;
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: 0.2s;
      }
      .bubble:hover .toolbar {
        opacity: 1;
      }
      .err {
        background: var(--error) !important;
        border: 1px solid rgba(255, 0, 0, 0.15);
      }
      .thinking {
        display: inline-flex;
        gap: 3px;
        align-items: center;
      }
      .thinking i {
        width: 6px;
        height: 6px;
        border-radius: 99px;
        background: var(--muted);
        opacity: 0.5;
        animation: blink 1s infinite ease-in-out;
      }
      .thinking i:nth-child(2) {
        animation-delay: 0.15s;
      }
      .thinking i:nth-child(3) {
        animation-delay: 0.3s;
      }
      @keyframes blink {
        0%,
        80%,
        100% {
          opacity: 0.2;
        }
        40% {
          opacity: 1;
        }
      }
      /* composer */
      .composer-wrap {
        border-top: 1px solid rgba(255, 255, 255, 0.06);
        background: var(--panel);
        padding: 12px 10px;
      }
      .composer {
        max-width: 980px;
        margin: 0 auto;
      }
      textarea {
        width: 100%;
        min-height: 70px;
        max-height: 220px;
        resize: vertical;
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: #0a0f14;
        color: var(--text);
      }
      [data-theme="light"] textarea {
        background: #fff;
        border-color: #e6e8ee;
      }
      .composer-row {
        margin-top: 10px;
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .stats {
        font-size: 12px;
        color: var(--muted);
      }
      .spacer {
        flex: 1;
      }
      .hidden {
        display: none !important;
      }
    </style>

    <!-- Markdown + highlighting -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/marked@12/lib/marked.umd.min.js"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.9.0/styles/github-dark.min.css"
    />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.9.0/highlight.min.js"
    ></script>
    <!-- dayjs for timestamps -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"
    ></script>
  </head>
  <body>
    <div class="wrap" id="app" data-theme="dark">
      <header>
        <div class="row">
          <div class="title">
            <span class="dot"></span> Keilani Chat •
            <span class="mono">Streaming</span>
          </div>
          <select id="model">
            <option value="gpt-5">gpt-5</option>
            <option value="gpt-4.1-mini">gpt-4.1-mini</option>
            <option value="gpt-4o-mini">gpt-4o-mini</option>
          </select>
          <input
            id="api"
            class="grow mono"
            placeholder="https://api.keilani.ai/api/chat"
          />
          <input
            id="token"
            class="mono"
            placeholder="Client Token (optional)"
          />
          <button id="save" class="pill">Save</button>
          <button id="export" class="pill">Export .txt</button>
          <button id="clear" class="pill ghost">Clear</button>
          <button id="reset" class="pill ghost">Reset Session</button>
          <button id="theme" class="pill iconbtn" title="Theme">🌗</button>
          <label class="pill"
            ><input type="checkbox" id="stream" checked /> Stream</label
          >
          <label class="pill"
            ><input type="checkbox" id="sse" checked /> Expect SSE</label
          >
        </div>
        <div class="row" style="margin-top: 8px">
          <select id="persona">
            <option value="">Persona: Default</option>
            <option value="friendly">Persona: Friendly Mentor</option>
            <option value="playful">Persona: Playful Gamer</option>
            <option value="waifu">Persona: Affectionate Waifu</option>
          </select>
          <select id="sessions"></select>
          <button id="newSession" class="pill">New Session</button>
          <span class="pill stats" id="sid"></span>
          <span class="pill stats" id="tokens">Tokens: 0 • 0 t/s</span>
          <button id="raw" class="pill ghost">Raw Inspector</button>
        </div>
      </header>

      <div class="scroll" id="scroll">
        <div class="chat" id="chat"></div>
      </div>

      <div class="composer-wrap">
        <div class="composer">
          <textarea
            id="prompt"
            placeholder="Type your message…  (Enter to send • Shift+Enter for newline)"
          ></textarea>
          <div class="composer-row">
            <div class="stats" id="hint">
              Tip: Ctrl/Cmd+K to focus input • ↑ to edit last message
            </div>
            <div class="spacer"></div>
            <button id="send" class="pill brand">Send ↵</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Raw inspector panel -->
    <pre
      id="rawpanel"
      class="hidden"
      style="
        position: fixed;
        inset: auto 10px 10px 10px;
        max-height: 40vh;
        overflow: auto;
        background: #0a0f14;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 10px;
        box-shadow: var(--shadow);
      "
    ></pre>

    <script>
      (() => {
        const qs = (sel) => document.querySelector(sel);
        const el = {
          model: qs("#model"),
          api: qs("#api"),
          token: qs("#token"),
          save: qs("#save"),
          clear: qs("#clear"),
          export: qs("#export"),
          reset: qs("#reset"),
          stream: qs("#stream"),
          sse: qs("#sse"),
          theme: qs("#theme"),
          sessions: qs("#sessions"),
          newSession: qs("#newSession"),
          persona: qs("#persona"),
          sid: qs("#sid"),
          tokens: qs("#tokens"),
          raw: qs("#raw"),
          rawpanel: qs("#rawpanel"),
          scroll: qs("#scroll"),
          chat: qs("#chat"),
          prompt: qs("#prompt"),
          send: qs("#send"),
          app: qs("#app"),
        };

        // ---------- persistence ----------
        const store = {
          get k() {
            return JSON.parse(localStorage.getItem("kln.chat") || "{}");
          },
          set v(obj) {
            localStorage.setItem("kln.chat", JSON.stringify(obj));
          },
        };
        const state = Object.assign(
          {
            api: "https://api.keilani.ai/api/chat",
            model: "gpt-5",
            token: localStorage.getItem("CLIENT_TOKEN") || "",
            sse: true,
            stream: true,
            theme: localStorage.getItem("THEME") || "dark",
            sid: crypto.randomUUID().slice(0, 8),
            sessions: {},
            persona: "",
          },
          store.k,
        );

        function persist() {
          store.v = {
            api: el.api.value,
            model: el.model.value,
            token: el.token.value,
            sse: el.sse.checked,
            stream: el.stream.checked,
            theme: el.app.dataset.theme,
            sid: state.sid,
            sessions: state.sessions,
            persona: el.persona.value,
          };
          localStorage.setItem("CLIENT_TOKEN", el.token.value || "");
          localStorage.setItem("THEME", el.app.dataset.theme);
        }

        function hydrate() {
          el.api.value = state.api;
          el.model.value = state.model;
          el.token.value = state.token;
          el.sse.checked = state.sse;
          el.stream.checked = state.stream;
          el.app.dataset.theme = state.theme;
          el.persona.value = state.persona || "";
          setSID(state.sid);
          loadSessions();
        }

        function setSID(sid) {
          state.sid = sid;
          el.sid.textContent = `SID: ${sid}`;
        }

        function loadSessions() {
          const list = el.sessions;
          list.innerHTML = "";
          const sids = Object.keys(state.sessions);
          const opt = document.createElement("option");
          opt.value = state.sid;
          opt.textContent = `Active: ${state.sid}`;
          list.appendChild(opt);
          if (sids.length) {
            const grp = document.createElement("optgroup");
            grp.label = "Saved Sessions";
            sids.forEach((k) => {
              const o = document.createElement("option");
              o.value = k;
              o.textContent = k;
              grp.appendChild(o);
            });
            list.appendChild(grp);
          }
        }

        // ---------- UI helpers ----------
        function bubble(
          role,
          html,
          { err = false, meta = "", id = crypto.randomUUID() } = {},
        ) {
          const container = document.createElement("div");
          container.className = `msg ${role === "user" ? "me" : "ai"}`;
          container.dataset.id = id;

          const bubble = document.createElement("div");
          bubble.className = `bubble ${err ? "err" : ""}`;
          bubble.innerHTML = html;

          // toolbar
          const toolbar = document.createElement("div");
          toolbar.className = "toolbar";
          const copy = btn("📋", "Copy");
          copy.onclick = () => copyText(bubble.innerText);
          toolbar.appendChild(copy);

          if (err) {
            const retry = btn("⟳", "Retry");
            retry.onclick = () => retryLast();
            toolbar.appendChild(retry);
          } else if (role === "user") {
            const edit = btn("✎", "Edit & resend");
            edit.onclick = () => {
              el.prompt.value = plainTextFromHTML(html);
              el.prompt.focus();
            };
            toolbar.appendChild(edit);
          }
          bubble.appendChild(toolbar);

          // meta (latency etc.)
          const metaEl = document.createElement("div");
          metaEl.className = "meta";
          metaEl.textContent = meta || dayjs().format("h:mm A");
          container.appendChild(bubble);
          container.appendChild(metaEl);

          el.chat.appendChild(container);
          autoscroll();
          return { container, bubble, meta: metaEl };
        }
        function btn(text, title) {
          const b = document.createElement("button");
          b.className = "pill iconbtn";
          b.title = title;
          b.textContent = text;
          return b;
        }
        function copyText(t) {
          navigator.clipboard.writeText(t).catch(() => {});
        }
        function plainTextFromHTML(h) {
          const d = document.createElement("div");
          d.innerHTML = h;
          return d.innerText;
        }

        let scrollLock = false;
        el.scroll.addEventListener("scroll", () => {
          const nearBottom =
            el.scroll.scrollTop + el.scroll.clientHeight >=
            el.scroll.scrollHeight - 40;
          scrollLock = !nearBottom; // lock if user scrolled up
        });
        function autoscroll() {
          if (scrollLock) return;
          el.scroll.scrollTo({
            top: el.scroll.scrollHeight,
            behavior: "smooth",
          });
        }

        function typingBubble() {
          const id = `think-${crypto.randomUUID()}`;
          const t = bubble(
            "ai",
            `<span class="thinking"><i></i><i></i><i></i></span>`,
            { id },
          );
          return { id, ...t };
        }

        // ---------- Markdown rendering ----------
        function renderMarkdown(text) {
          try {
            const html = marked.parse(text, {
              breaks: true,
              gfm: true,
            });
            return html.replace(
              /<pre><code class="language-(.*?)">/g,
              '<pre><code class="language-$1 hljs">',
            );
          } catch {
            return text;
          }
        }
        function highlightLater(root) {
          root.querySelectorAll("pre code").forEach((block) => {
            try {
              hljs.highlightElement(block);
            } catch {}
          });
        }

        // ---------- Token stats ----------
        let totalTokens = 0,
          lastTick = 0,
          lastTokens = 0;
        function tickTokens(incr = 0) {
          totalTokens += incr;
          const now = performance.now();
          if (now - lastTick > 500) {
            const rate = (
              (totalTokens - lastTokens) /
              ((now - lastTick) / 1000 + 1e-9)
            ).toFixed(1);
            lastTick = now;
            lastTokens = totalTokens;
            el.tokens.textContent = `Tokens: ${totalTokens} • ${rate} t/s`;
          }
        }

        // ---------- Composer Shortcuts ----------
        window.addEventListener("keydown", (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
            e.preventDefault();
            el.prompt.focus();
          }
          if (
            document.activeElement === el.prompt &&
            e.key === "ArrowUp" &&
            !el.prompt.value
          ) {
            // edit last user message
            const lastUser = [...el.chat.querySelectorAll(".me .bubble")].pop();
            if (lastUser) {
              el.prompt.value = lastUser.innerText;
              setTimeout(
                () =>
                  el.prompt.setSelectionRange(
                    el.prompt.value.length,
                    el.prompt.value.length,
                  ),
                0,
              );
            }
          }
        });

        // ---------- Networking (SSE) ----------
        async function sendMessage() {
          const text = el.prompt.value.trim();
          if (!text) return;
          el.prompt.value = "";
          const user = bubble("user", escapeHTML(text));
          const think = typingBubble();

          const system = personaToSystem(el.persona.value);
          const body = {
            model: el.model.value,
            stream: el.stream.checked,
            messages: [
              ...(system ? [{ role: "system", content: system }] : []),
              { role: "user", content: text },
            ],
            // sid threading via header (below)
          };

          const headers = { "Content-Type": "application/json" };
          if (el.token.value)
            headers["Authorization"] = `Bearer ${el.token.value}`;
          headers["X-Session-ID"] = state.sid;

          const t0 = performance.now();
          try {
            const res = await fetch(el.api.value || state.api, {
              method: "POST",
              headers,
              body: JSON.stringify(body),
            });
            if (!res.ok) {
              const errText = await res.text().catch(() => res.statusText);
              throw new Error(`[HTTP ${res.status}] ${errText}`);
            }

            if (el.sse.checked) {
              await readSSE(res, think, t0);
            } else {
              const data = await res.json();
              el.rawpanelLog(data);
              const content =
                data.output_text || data.content || JSON.stringify(data);
              finalize(think, content, t0);
            }
          } catch (err) {
            finalize(think, `**[Error]** ${escapeHTML(err.message)}`, t0, true);
          } finally {
            persist();
          }
        }

        async function readSSE(res, think, t0) {
          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let buf = "";
          for (;;) {
            const { value, done } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            buf += chunk;

            // raw inspector
            el.rawpanelLog(chunk);

            // Parse by lines (simple SSE)
            const lines = chunk.split(/\r?\n/);
            for (const line of lines) {
              if (!line.startsWith("data:")) continue;
              const data = line.slice(5).trim();
              if (!data || data === "[DONE]") continue;

              let json;
              try {
                json = JSON.parse(data);
              } catch {
                continue;
              }
              // The proxy may stream {delta:"..."} or {content:"..."}; consume both
              const delta =
                json.delta ?? json.content ?? json.output_text ?? "";
              if (delta) {
                updateThinking(think, delta);
                tickTokens((delta.length / 4) | 0); // rough char->token approximation
              }
              if (json.usage && json.usage.total_tokens) {
                totalTokens += json.usage.total_tokens;
              }
            }
          }
          finalizeThinking(think, t0);
        }

        function updateThinking(think, delta) {
          // Convert current bubble content to markdown, append delta
          const cur = think.bubble.dataset.raw || "";
          const nextRaw = cur + delta;
          think.bubble.dataset.raw = nextRaw;
          think.bubble.innerHTML = renderMarkdown(nextRaw);
          highlightLater(think.bubble);
          autoscroll();
        }

        function finalizeThinking(think, t0) {
          const raw = think.bubble.dataset.raw || "";
          finalize(think, raw, t0);
        }

        function finalize(think, content, t0, isErr = false) {
          const ms = Math.max(1, Math.round(performance.now() - t0));
          think.bubble.innerHTML = renderMarkdown(content);
          if (isErr) think.bubble.classList.add("err");
          think.meta.textContent = `${dayjs().format("h:mm A")} • ⏱ ${ms} ms`;
          highlightLater(think.bubble);
          autoscroll();
        }

        function retryLast() {
          const lastUser = [...el.chat.querySelectorAll(".me .bubble")].pop();
          if (!lastUser) return;
          el.prompt.value = lastUser.innerText;
          el.prompt.focus();
        }

        function personaToSystem(key) {
          if (key === "friendly")
            return "You're Keilani, a friendly, helpful mentor. Be concise, encouraging, and clear.";
          if (key === "playful")
            return "You're Keilani, a witty gamer-teammate. Be playful, brief, and supportive.";
          if (key === "waifu")
            return "You're Keilani, a sweet, affectionate companion. Keep replies SFW and caring.";
          return "";
        }

        // ---------- Raw inspector ----------
        el.rawpanelLog = function logRaw(x) {
          if (el.rawpanel.classList.contains("hidden")) return;
          const s = typeof x === "string" ? x : JSON.stringify(x, null, 2);
          el.rawpanel.textContent += s + (s.endsWith("\n") ? "" : "\n");
          el.rawpanel.scrollTop = el.rawpanel.scrollHeight;
        };
        el.raw.onclick = () => {
          el.rawpanel.classList.toggle("hidden");
        };

        // ---------- Utils ----------
        function escapeHTML(s) {
          return s.replace(
            /[&<>"']/g,
            (m) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              })[m],
          );
        }

        // ---------- Export / Clear / Sessions ----------
        el.export.onclick = () => {
          const text = [...el.chat.querySelectorAll(".msg")]
            .map((m) => {
              const who = m.classList.contains("me") ? "You" : "Keilani";
              return `${who}: ${m.querySelector(".bubble").innerText}`;
            })
            .join("\n\n");
          const blob = new Blob([text], { type: "text/plain" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = `keilani-${state.sid}.txt`;
          a.click();
        };
        el.clear.onclick = () => {
          el.chat.innerHTML = "";
          totalTokens = 0;
          tickTokens(0);
        };
        el.reset.onclick = () => {
          state.sessions[state.sid] = el.chat.innerHTML;
          setSID(crypto.randomUUID().slice(0, 8));
          el.chat.innerHTML = "";
          loadSessions();
          persist();
        };
        el.newSession.onclick = () => {
          state.sessions[state.sid] = el.chat.innerHTML;
          setSID(crypto.randomUUID().slice(0, 8));
          el.chat.innerHTML = "";
          loadSessions();
          persist();
        };
        el.sessions.onchange = (e) => {
          const selected = e.target.value;
          if (!selected || selected === state.sid) return;
          // swap
          state.sessions[state.sid] = el.chat.innerHTML;
          el.chat.innerHTML = state.sessions[selected] || "";
          setSID(selected);
          loadSessions();
          persist();
        };

        // ---------- Theme ----------
        el.theme.onclick = () => {
          el.app.dataset.theme =
            el.app.dataset.theme === "dark" ? "light" : "dark";
          persist();
        };

        // ---------- Save + Send handlers ----------
        el.save.onclick = persist;
        el.send.onclick = sendMessage;
        el.prompt.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            el.send.click();
          }
        });

        // ---------- Boot ----------
        hydrate();

        // helpful default
        tickTokens(0);

        // focus on Ctrl/Cmd+K
        // already installed above
      })();
    </script>
  </body>
</html>
