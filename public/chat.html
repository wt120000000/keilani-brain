<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
/>
<title>Keilani • Chat Streaming</title>
<style>
  :root {
    --bg:#0b0d12; --fg:#e7e9ee; --muted:#98a2b3; --panel:#10131a; --panel2:#0f1218;
    --acc:#6d5efc; --acc-2:#8f87ff; --err:#ff4d4d; --ok:#2ecc71; --chip:#1b2030;
    --br:12px;
  }
  html,body{height:100%;}
  body{margin:0; background:var(--bg); color:var(--fg); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  .bar{display:flex; gap:.5rem; align-items:center; padding:.75rem; background:var(--panel); position:sticky; top:0; z-index:5; border-bottom:1px solid #161a23}
  .brand{display:flex; align-items:center; gap:.5rem; font-weight:600}
  .dot{width:8px;height:8px;border-radius:999px;background:var(--ok);box-shadow:0 0 0 2px rgba(46,204,113,.15)}
  select, input[type=text]{height:36px; background:var(--panel2); border:1px solid #202634; border-radius:10px; color:var(--fg); padding:0 .6rem; outline:none}
  select:focus, input[type=text]:focus{border-color:#2a3350}
  .btn{height:36px; border:1px solid #242b3a; background:#131827; color:var(--fg); border-radius:10px; padding:0 .8rem; cursor:pointer}
  .btn:hover{background:#171d2e}
  .btn.primary{background:var(--acc); border-color:var(--acc); color:#fff}
  .btn.primary:hover{background:var(--acc-2)}
  .btn.ghost{background:transparent; border-color:#2a3150}
  .grow{flex:1 1 auto}
  .small{font-size:12px;color:var(--muted)}
  .chip{background:var(--chip); color:#c8d1e6; padding:.2rem .5rem; border-radius:999px; font-size:12px}
  .wrap{max-width:1080px; margin:0 auto; padding:1rem; display:flex; flex-direction:column; gap:1rem}
  .log{display:flex; flex-direction:column; gap:.75rem; min-height:48dvh}
  .bubble{background:var(--panel); border:1px solid #161b26; border-radius:14px; padding:1rem; white-space:pre-wrap}
  .bubble.you{background:#0f1422; border-color:#1b2131}
  .row{display:flex; gap:.75rem}
  textarea{background:var(--panel2); border:1px solid #202634; border-radius:12px; color:var(--fg); padding:.8rem; resize:vertical; min-height:64px; max-height:40dvh; outline:none}
  textarea:focus{border-color:#2a3350}
  .composer{display:flex; gap:.75rem; align-items:flex-end; position:sticky; bottom:0; padding-bottom:.5rem; background:linear-gradient(180deg, rgba(11,13,18,0) 0%, rgba(11,13,18,1) 40%)}
  .err{background:#2a0f14; border:1px solid #4a141a; color:#ffb0b0; border-radius:12px; padding:.8rem}
  .hidden{display:none}
  .right{margin-left:auto}
  .kbd{font:12px/1.1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background:#121724; border:1px solid #222a3e; padding:.1rem .35rem; border-radius:6px; color:#b9c1de}
  .meta{display:flex; align-items:center; gap:.5rem; color:var(--muted)}
</style>
</head>
<body>
  <div class="bar">
    <div class="brand"><span class="dot"></span> Keilani Chat • <span class="small">Streaming</span></div>

    <select id="model" title="Model">
      <option value="gpt-5" selected>gpt-5</option>
      <option value="gpt-4.1">gpt-4.1</option>
      <option value="gpt-4o-mini">gpt-4o-mini</option>
    </select>

    <input id="api" class="grow" type="text" placeholder="https://api.keilani.ai/api/chat" />

    <input id="token" type="text" placeholder="Client Token (optional)" style="width:280px" />

    <button id="save" class="btn">Save</button>
    <button id="export" class="btn">Export .txt</button>
    <button id="clear" class="btn">Clear</button>
  </div>

  <div class="wrap">
    <div id="err" class="err hidden"></div>

    <div class="log" id="log"></div>

    <div class="meta">
      <span id="tokChip" class="chip">Tokens: 0 • 0 t/s</span>
      <span id="sidChip" class="chip right">SID: —</span>
    </div>

    <div class="composer">
      <textarea id="prompt" class="grow" placeholder="Type your message…  (Shift+Enter for newline)"></textarea>
      <div style="display:flex; flex-direction:column; gap:.5rem;">
        <label class="small"><input id="stream" type="checkbox" checked /> Stream</label>
        <label class="small"><input id="sse" type="checkbox" checked /> Expect SSE</label>
      </div>
      <button id="send" class="btn primary" style="height:48px">Send ↵</button>
    </div>

    <div class="small">Tip: <span class="kbd">Enter</span> to send • <span class="kbd">Shift</span>+<span class="kbd">Enter</span> for newline • Your config persists locally</div>
  </div>

<script>
(() => {
  const $ = (s) => document.querySelector(s);
  const model = $('#model');
  const api = $('#api');
  const token = $('#token');
  const saveBtn = $('#save');
  const exportBtn = $('#export');
  const clearBtn = $('#clear');
  const promptEl = $('#prompt');
  const sendBtn = $('#send');
  const streamEl = $('#stream');
  const sseEl = $('#sse');
  const log = $('#log');
  const errBox = $('#err');
  const sidChip = $('#sidChip');
  const tokChip = $('#tokChip');

  // ---- session + persistence ------------------------------------------------
  const SID = crypto.randomUUID().slice(0, 8);
  sidChip.textContent = `SID: ${SID}`;

  const LS = {
    get k() { return 'kln.chat.v1'; },
    load() {
      try { return JSON.parse(localStorage.getItem(this.k) || '{}'); }
      catch { return {}; }
    },
    save(v) { localStorage.setItem(this.k, JSON.stringify(v)); }
  };

  const conf = Object.assign({
    model: 'gpt-5',
    api: 'https://api.keilani.ai/api/chat',
    token: '',
    stream: true,
    sse: true
  }, LS.load());

  model.value = conf.model;
  api.value = conf.api;
  token.value = conf.token || '';
  streamEl.checked = !!conf.stream;
  sseEl.checked = !!conf.sse;

  saveBtn.onclick = () => {
    LS.save({
      model: model.value,
      api: api.value.trim(),
      token: token.value.trim(),
      stream: streamEl.checked,
      sse: sseEl.checked
    });
    flash(`Saved.`, 'ok');
  };

  exportBtn.onclick = () => {
    const text = [...log.querySelectorAll('.bubble')].map(n => n.textContent).join('\n\n---\n\n');
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `keilani-chat-${new Date().toISOString().slice(0,19)}.txt`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  };

  clearBtn.onclick = () => { log.innerHTML = ''; };

  function flash(msg, kind='error') {
    errBox.textContent = msg;
    errBox.classList.remove('hidden');
    errBox.style.background = kind === 'ok' ? '#0f1d15' : '#2a0f14';
    errBox.style.borderColor = kind === 'ok' ? '#184d33' : '#4a141a';
    setTimeout(() => errBox.classList.add('hidden'), 3500);
  }

  // ---- UI helpers -----------------------------------------------------------
  function addBubble(text, who='you') {
    const b = document.createElement('div');
    b.className = 'bubble ' + (who === 'you' ? 'you' : '');
    b.textContent = text;
    log.appendChild(b);
    b.scrollIntoView({ behavior: 'smooth', block: 'end' });
  }

  function setErrorBanner(text = '') {
    if (!text) { errBox.classList.add('hidden'); return; }
    errBox.textContent = text;
    errBox.classList.remove('hidden');
  }

  // ---- Build messages[] properly -------------------------------------------
  function buildMessages(userText) {
    // Minimal, safe system prompt (keeps payload shape correct)
    const messages = [
      { role: 'system', content: 'You are Keilani, a helpful AI companion. Keep answers succinct unless asked.' },
      { role: 'user', content: userText }
    ];
    return messages;
  }

  // ---- Streaming with fetch + SSE ------------------------------------------
  async function streamChat() {
    setErrorBanner('');

    const text = promptEl.value.trim();
    if (!text) return;

    // UI updates
    addBubble(text, 'you');
    promptEl.value = '';
    sendBtn.disabled = true;

    const payload = {
      model: model.value,
      stream: !!streamEl.checked,
      messages: buildMessages(text)
    };

    const headers = { 'Content-Type': 'application/json' };
    const t = token.value.trim();
    if (t) headers['Authorization'] = `Bearer ${t}`;

    let resp;
    try {
      resp = await fetch(api.value.trim(), {
        method: 'POST',
        headers,
        body: JSON.stringify(payload)
      });
    } catch (e) {
      sendBtn.disabled = false;
      flash(`Network error: ${e.message}`);
      return;
    }

    // Non-OK => show server’s text
    if (!resp.ok) {
      const errText = await resp.text().catch(()=>String(resp.status));
      addBubble(`[Error] HTTP ${resp.status}\n\n${errText}`, 'bot');
      sendBtn.disabled = false;
      return;
    }

    // If streaming, read as SSE; otherwise parse JSON once
    if (streamEl.checked && (sseEl.checked || resp.headers.get('content-type')?.includes('text/event-stream'))) {
      const reader = resp.body.getReader();
      const dec = new TextDecoder('utf-8');
      let acc = '';
      const bot = document.createElement('div');
      bot.className = 'bubble';
      log.appendChild(bot);

      const t0 = performance.now();
      let tokens = 0;

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        const chunk = dec.decode(value, { stream: true });
        // Basic SSE framing: lines starting with "data:"
        const lines = (acc + chunk).split('\n');
        acc = lines.pop() || '';
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed.startsWith('data:')) continue;
          const data = trimmed.slice(5).trim();
          if (data === '[DONE]') break;
          try {
            const obj = JSON.parse(data);
            // Two possible shapes:
            // 1) Our proxy forwards OpenAI SSE frames as { delta: "..." }
            // 2) Or direct chunk has { choices: [{ delta: { content } }] }
            let delta =
              obj?.delta ??
              obj?.choices?.[0]?.delta?.content ??
              obj?.choices?.[0]?.text ??
              obj?.content ??
              '';
            if (typeof delta !== 'string') delta = '';
            if (delta) {
              bot.textContent += delta;
              tokens += 1;
            }
          } catch { /* ignore parse errors */ }
        }
        bot.scrollIntoView({ behavior: 'smooth', block: 'end' });
        const dt = (performance.now() - t0) / 1000;
        tokChip.textContent = `Tokens: ${tokens} • ${(tokens/dt||0).toFixed(1)} t/s`;
      }
      sendBtn.disabled = false;
      return;
    }

    // Non-stream JSON
    try {
      const data = await resp.json();
      const content =
        data?.choices?.[0]?.message?.content ??
        data?.message ??
        JSON.stringify(data, null, 2);
      addBubble(content, 'bot');
    } catch {
      addBubble(await resp.text(), 'bot');
    }
    sendBtn.disabled = false;
  }

  // ---- Keyboard: Enter to send, Shift+Enter newline ------------------------
  promptEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      streamChat();
    }
  });
  sendBtn.onclick = streamChat;

  // ---- Initial “Saved” hint once -------------------------------------------
  if (!LS.load().__seenHint) {
    flash('Fields persist to localStorage. Click “Save” after you change API or token.', 'ok');
    const v = LS.load(); v.__seenHint = true; LS.save(v);
  }
})();
</script>
</body>
</html>
