<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Keilani • Chat + Voice + RTC</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 24px; background: #0b0b0f; color: #e7e7ee; }
    .wrap { max-width: 960px; margin: 0 auto; }
    h1 { margin: 0 0 8px; }
    .card { background: #12121a; border: 1px solid #1f1f2a; border-radius: 16px; padding: 16px; margin-bottom: 16px; }
    label { font-size: 12px; color: #9aa3b2; display: block; margin-bottom: 6px; }
    input, textarea, button {
      border-radius: 10px; border: 1px solid #2a2a38; background: #161622; color: #e7e7ee;
      padding: 10px; width: 100%;
    }
    textarea { min-height: 90px; resize: vertical; }
    .row { display: grid; gap: 12px; grid-template-columns: 1fr 1fr; }
    .col { display: flex; flex-direction: column; gap: 8px; }
    .btn { cursor: pointer; }
    .btn-primary { background: #1f2937; border-color: #2f3a4f; }
    .btn-accent { background: #0f5132; border-color: #0b3e27; }
    .btn-warn { background: #512a0f; border-color: #3e210b; }
    .flex { display: flex; gap: 8px; align-items: center; }
    .log { white-space: pre-wrap; background: #0d0d14; padding: 10px; border-radius: 10px; min-height: 60px; }
    iframe { width: 100%; height: 540px; border: 0; border-radius: 12px; background: #000; }
    .small { font-size: 12px; color: #9aa3b2; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Keilani • Chat + Voice + RTC</h1>
  <p class="small">MVP stack: GPT-5 chat, Whisper STT, ElevenLabs TTS, and Daily for camera/screen-share. Avatar hook is prewired for later.</p>

  <div class="card">
    <div class="row">
      <div class="col">
        <label>Type to chat</label>
        <textarea id="textIn" placeholder="Say hi to Keilani…"></textarea>
        <div class="flex">
          <button class="btn btn-primary" id="sendText">Send</button>
          <button class="btn" id="speakReply">Speak Reply</button>
        </div>
      </div>
      <div class="col">
        <label>Push-to-talk</label>
        <div class="flex">
          <button class="btn btn-accent" id="pttBtn">Hold to talk</button>
          <span id="recState" class="small">idle</span>
        </div>
        <label>Last transcript</label>
        <div id="transcript" class="log"></div>
      </div>
    </div>

    <label>Keilani says</label>
    <div id="reply" class="log"></div>
    <audio id="ttsPlayer" controls></audio>
  </div>

  <div class="card">
    <h3>Camera & Screen-share (Daily)</h3>
    <div class="flex">
      <button class="btn btn-primary" id="createRoom">Create room</button>
      <button class="btn" id="openRoom">Open room</button>
      <button class="btn btn-warn" id="closeRoom">Close room</button>
      <span id="roomInfo" class="small">No room yet.</span>
    </div>
    <div id="dailyMount"></div>
    <p class="small">Use the embedded Daily UI controls to enable mic/camera and share your screen.</p>
  </div>

  <div class="card">
    <h3>Avatar Hook (placeholder)</h3>
    <p class="small">We forward LLM text here and can add phoneme timing later to lip-sync your chosen avatar service.</p>
    <div id="avatarFeed" class="log"></div>
  </div>
</div>

<script>
const $ = (id) => document.getElementById(id);
const state = {
  mediaRecorder: null,
  chunks: [],
  dailyRoom: null,
  dailyUrl: null,
  meetingToken: null,
  lastReply: "",
};

// TEXT CHAT
$("sendText").onclick = async () => {
  const message = $("textIn").value.trim();
  if (!message) return;
  const reply = await chat(message);
  $("reply").textContent = reply;
  state.lastReply = reply;
  feedAvatar(reply);
};

$("speakReply").onclick = async () => {
  if (!state.lastReply) return;
  const audioUrl = await tts(state.lastReply);
  if (audioUrl) {
    const player = $("ttsPlayer");
    player.src = audioUrl;
    player.play();
  }
};

// PUSH-TO-TALK (record → /api/stt → /api/chat → /api/tts)
const pttBtn = $("pttBtn");
pttBtn.onmousedown = startRecording;
pttBtn.onmouseup = stopRecording;
pttBtn.ontouchstart = (e) => { e.preventDefault(); startRecording(); };
pttBtn.ontouchend = (e) => { e.preventDefault(); stopRecording(); };

async function startRecording() {
  $("recState").textContent = "recording…";
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  state.chunks = [];
  state.mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
  state.mediaRecorder.ondataavailable = (e) => state.chunks.push(e.data);
  state.mediaRecorder.onstop = async () => {
    $("recState").textContent = "processing…";
    const blob = new Blob(state.chunks, { type: "audio/webm" });
    const b64 = await blobToBase64(blob);

    const stt = await fetch("/api/stt", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ audioBase64: b64 })
    }).then(r => r.json()).catch(() => ({}));

    $("transcript").textContent = stt.text || "";
    if (stt.text) {
      const reply = await chat(stt.text);
      $("reply").textContent = reply;
      state.lastReply = reply;
      feedAvatar(reply);

      const audioUrl = await tts(reply);
      if (audioUrl) {
        const player = $("ttsPlayer");
        player.src = audioUrl;
        player.play();
      }
    }
    $("recState").textContent = "idle";
  };
  state.mediaRecorder.start();
}

function stopRecording() {
  if (state.mediaRecorder && state.mediaRecorder.state !== "inactive") {
    state.mediaRecorder.stop();
  }
}

function blobToBase64(blob) {
  return new Promise((res) => {
    const reader = new FileReader();
    reader.onloadend = () => res(reader.result);
    reader.readAsDataURL(blob);
  });
}

async function chat(message) {
  const r = await fetch("/api/chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message })
  });
  if (!r.ok) {
    console.error("chat error", await r.text());
    return "";
  }
  const j = await r.json();
  return j.reply || "";
}

async function tts(text) {
  const r = await fetch("/api/tts", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text })
  });
  if (!r.ok) {
    console.error("TTS error", await r.text());
    return "";
  }
  const blob = await r.blob();
  return URL.createObjectURL(blob);
}

// DAILY ROOM CONTROLS (camera/screen-share)
$("createRoom").onclick = async () => {
  const r = await fetch("/api/rtc/create-room", { method: "POST" });
  if (!r.ok) {
    console.error("create room error", await r.text());
    return;
  }
  const j = await r.json();
  state.dailyRoom = j.room;
  state.dailyUrl = j.url;
  $("roomInfo").textContent = `Room: ${j.room}`;
};

let iframe;
$("openRoom").onclick = async () => {
  if (!state.dailyRoom) {
    await $("createRoom").onclick();
  }
  const tokenRes = await fetch("/api/rtc/token", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ room: state.dailyRoom, userName: "Guest" })
  });
  const tokenJson = tokenRes.ok ? await tokenRes.json() : {};
  state.meetingToken = tokenJson.token;

  const mount = $("dailyMount");
  mount.innerHTML = "";
  iframe = document.createElement("iframe");
  const url = new URL(state.dailyUrl);
  if (state.meetingToken) url.searchParams.set("t", state.meetingToken);
  iframe.src = url.toString();
  mount.appendChild(iframe);
};

$("closeRoom").onclick = () => {
  $("dailyMount").innerHTML = "";
  iframe = null;
};

// AVATAR HOOK (placeholder)
function feedAvatar(text) {
  $("avatarFeed").textContent = (text || "").slice(0, 1200);
}
</script>
</body>
</html>
